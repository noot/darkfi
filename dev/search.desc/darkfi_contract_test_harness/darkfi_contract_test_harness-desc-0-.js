searchState.loadedDescShard("darkfi_contract_test_harness", 0, "Enum representing available wallet holders\nNative contract test harness instance\nWallet instance for a single <code>Holder</code>\nCreate and append a <code>Money::Fee</code> call to a given <code>Transaction</code> …\nAssert that all holders’ trees are the same\nCreate bench.csv file\n<code>Deployooor::Deploy</code> functionality\nKeypair for arbitrary contract deployment\nCreate an empty transaction that includes a <code>Money::Fee</code> …\n<code>Dao::Exec</code> functionality\nCreate a <code>Dao::Exec</code> transaction.\nWitnessed leaf positions of DAO bullas in the …\nHolder’s instance of the Merkle tree for the <code>DAO</code> …\n<code>Dao::Mint</code> functionality\nCreate a <code>Dao::Mint</code> transaction with the given <code>Dao</code> info and …\nDao Proposal snapshots\nHolder’s instance of the Merkle tree for the <code>DAO</code> …\n<code>Dao::Propose</code> functionality\nCreate a <code>Dao::Propose</code> transaction.\n<code>Dao::Vote</code> functionality\nCreate a <code>Dao::Vote</code> transaction.\nCreate a <code>Deployooor::Deploy</code> transaction with the given …\nExecute the transaction made by <code>dao_exec()</code> for a given …\nExecute the transaction created by <code>dao_mint()</code> for a given …\nExecute the transaction created by <code>dao_propose()</code> for a …\nExecute the transaction made by <code>dao_vote()</code> for a given …\nExecute the transaction created by <code>deploy_contract()</code> for a …\nExecute the transaction created by <code>create_empty_fee_call()</code> …\nExecute the <code>Transaction</code> created by <code>genesis_mint()</code>.\nExecute the transaction created by <code>otc_swap()</code> for a given …\nExecute the transaction created by <code>token_freeze()</code> for a …\nExecute the transaction created by <code>token_mint()</code> for a …\nExecute a <code>Money::Transfer</code> transaction for a given <code>Holder</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate and add an empty block to the given <code>Holder</code>s …\nThe genesis block for this harness\nCreate a <code>Money::GenesisMint</code> transaction for a given <code>Holder</code>.\nInitialized <code>Holder</code>s for this instance\nInitialize the logging mechanism\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMain holder keypair\n<code>Money::Fee</code> functionality\n<code>Money::GenesisMint</code> functionality\nHolder’s instance of the Merkle tree for the <code>Money</code> …\nHolder’s instance of the SMT tree for the <code>Money</code> contract\nHolder’s instance of the SMT tree for the <code>Money</code> contract …\n<code>Money::OtcSwap</code> functionality\n<code>Money::PoWReward</code> functionality\n<code>Money::TokenMint</code> functionality\n<code>Money::Transfer</code> functionality\nInstantiate a new <code>Wallet</code> instance\nInstantiate a new <code>TestHarness</code> given a slice of <code>Holder</code>s. …\nCreate a <code>Money::OtcSwap</code> transaction with two given <code>Holder</code>s.\nCreate a <code>Money::PoWReward</code> transaction for a given <code>Holder</code>.\nCached <code>ProvingKey</code>s for native contract ZK proving\nHolder’s set of spent <code>OwnCoin</code>s from the <code>Money</code> contract\nFreeze the supply of a minted token\nMint an arbitrary token for a given recipient using …\nKeypair for arbitrary token minting\nCreate a <code>Money::Transfer</code> transaction.\nHolder’s set of unspent <code>OwnCoin</code>s from the <code>Money</code> contract\nHolder’s <code>Validator</code> instance\nMarker to know if we’re supposed to include tx fees\nUtility module for caching ZK proof PKs and VKs\nUpdate these if any circuits are changed. Delete the …\n(Bincode, Namespace, VK)\n(Bincode, Namespace, VK)\nBuild a <code>PathBuf</code> to a cachefile\nGenerate or read cached PKs and VKs\nInject cached VKs into a given blockchain database …")