searchState.loadedDescShard("darkfi", 0, "This macro is used for a standard way of daemonizing …\nChunk-based file storage implementation. This is a …\n<code>src/zkas</code> is the library holding the zkas toolchain, …\nStructure holding all sled trees that define the concept …\nOverlay structure over a <code>Blockchain</code> instance.\nAtomic pointer to blockchain overlay.\nAtomic pointer to sled db overlay.\nInsert a given <code>BlockInfo</code> into the overlay. This functions …\nInsert a given <code>BlockInfo</code> into the blockchain database. …\nInsert a given slice of pending transactions into the …\nAuxiliary function to write to multiple trees completely …\nBlock related definitions and storage implementations\nBlocks overlay\nBlocks sled tree\nCheckpoint overlay so we can revert to it, if needed.\nContracts and Wasm storage implementations\nContract overlay\nContracts related sled trees\nReturns the argument unchanged.\nReturns the argument unchanged.\nAuxiliary function to create a full clone using …\nRetrieve genesis (first) block height and hash.\nRetrieve genesis (first) block info.\nRetrieve all blocks contained in the blockchain in order. …\nRetrieve <code>BlockInfo</code>s by given hashes. Fails if any of them …\nRetrieve <code>BlockInfo</code>s by given hashes. Fails if any of them …\nRetrieve <code>BlockInfo</code>s by given heights. Does not fail if any …\nRetrieve all <code>BlockInfo</code> for given slice of <code>Block</code>. Fails if …\nRetrieve all <code>BlockInfo</code> for given slice of <code>Block</code>. Fails if …\nRetrieve <code>Block</code>s by given hashes and return their …\nRetrieve n headers before given block height.\nRetrieve all transactions from the pending tx store. Be …\nCheck if the given <code>BlockInfo</code> is in the database and all …\nCheck if the given <code>BlockInfo</code> is in the database and all …\nCheck if block order for the given height is in the …\nHeader definition and storage implementation\nHeaders overlay\nHeaders sled tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if blockchain contains any blocks\nCheck if blockchain contains any blocks\nRetrieve the last block height and hash.\nRetrieve the last block height and hash.\nRetrieve the last block info.\nRetrieve the last block info.\nRetrieve the last block difficulty. If the tree is empty, …\nRetrieve the last block height.\nRetrieve the last block timestamp.\nRetrieve stored blocks count\nInstantiate a new <code>BlockchainOverlay</code> over the given …\nInstantiate a new <code>Blockchain</code> with the given <code>sled</code> database.\nMain <code>sled_overlay::SledDbOverlay</code> to the sled db connection\nParse a sled record in the form of a tuple (<code>key</code>, <code>value</code>).\nParse a sled record with a u32 key in the form of a tuple (…\nParse a sled record with a u64 key in the form of a tuple (…\nRemove a given slice of pending transactions from the …\nRemove a given slice of pending transactions hashes from …\nRevert to current overlay checkpoint.\nMain pointer to the sled db connection\nTransactions overlay\nTransactions related sled trees\nTransactions related storage implementations\nRetrieve stored txs count\nThis struct represents a tuple of the form (<code>header</code>, <code>txs</code>, …\nAuxiliary structure used to keep track of block PoW …\nStructure representing full block data, acting as a …\nAuxiliary structure used to keep track of blocks order.\nAuxiliary structure used to keep track of block ranking …\nThe <code>BlockStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>BlockStore</code> instance.\nAppend a transaction to the block. Also adds it to the …\nAuxiliary function to append a transaction to a Merkle …\nAppend a vector of transactions to the block. Also adds …\nBlock header hash of that height\nCheck if the store’s main tree contains a given block …\nCheck if the store’s order tree contains a given height.\nHeight cummulative difficulty (total + height difficulty)\nRepresents the genesis block on current timestamp\nHeight difficulty\nThe <code>sled</code> tree storing the the difficulty information of the\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a <code>Block</code> from a <code>BlockInfo</code>\nRepresents the genesis block difficulty\nFetch given block hashes from the overlay’s main tree. …\nFetch given block hashes from the store’s main tree. The …\nRetrieve all blocks from the store’s main tree in the …\nRetrieve all block difficulties from the store’s …\nRetrieve complete order from the store’s order tree in …\nFetch n hashes before given height. In the iteration, if …\nFetch given block height numbers from the store’s …\nFetch the first block hash in the order tree, based on the …\nFetch the last block hash in the overlay’s order tree, …\nFetch the last block hash in the order tree, based on the …\nFetch the last record in the difficulty tree, based on the …\nFetch the last N records from the store’s difficulty …\nFetch given heights from the overlay’s order tree. The …\nFetch given heights from the store’s order tree. The …\nA block’s hash is the same as the hash of its header\nA block’s hash is the same as the hash of its header\nBlock hash rank\nHeight cummulative hashes rank\nBlock header\nBlock header data\nBlock height\nBlock height number\nInsert a slice of <code>Block</code> into the overlay’s main tree. …\nInsert a slice of <code>Block</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>BlockDifficulty</code> into the overlay’s …\nInsert a slice of <code>BlockDifficulty</code> into the store’s …\nInsert a slice of <code>u32</code> and block hashes into overlay’s …\nInsert a slice of <code>u32</code> and block hashes into the store’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if overlay’s order tree contains any records.\nCheck if store’s order tree contains any records.\nRetrieve store’s order tree records count.\nMain <code>sled</code> tree, storing all the blockchain’s blocks, …\nOpens a new or existing <code>BlockStore</code> on the given sled …\nGenerate an empty block for provided Header. Transactions …\nThe <code>sled</code> tree storing the order of the blockchain’s …\nBlock ranks\nSign block header using provided secret key\nBlock producer signature\nBlock producer signature\nBlock target rank\nHeight cummulative targets rank\nBlock creation timestamp\nTrasaction hashes\nTransactions payload\nThe <code>ContractStore</code> is a structure representing all <code>sled</code> …\nOverlay structure over a <code>ContractStore</code> instance.\nThe hardcoded db name for the zkas circuits database tree\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetches the bincode for a given ContractId from the overlay…\nFetches the bincode for a given ContractId from the store…\nRetrieve all contract states from the store’s state tree …\nRetrieve all wasm bincodes from the store’s wasm tree in …\nAbstraction function for fetching a <code>ZkBinary</code> and its …\nAbstraction function for fetching a <code>ZkBinary</code> and its …\nTry to initialize a new contract state. Contracts can …\nInserts or replaces the bincode for a given ContractId …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDo a lookup of an existing contract state. In order to …\nDo a lookup of an existing contract state. In order to …\nOpens a new or existing <code>ContractStore</code> on the given sled …\nAttempt to remove an existing contract state. In order to …\nThe <code>sled</code> tree storing the pointers to contracts’ …\nThe <code>sled</code> tree storing the wasm bincode for deployed …\nThis struct represents a tuple of the form (version, …\nThe <code>HeaderStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>HeaderStore</code> instance.\nCheck if the store’s main tree contains a given header …\nRepresents the genesis header on current timestamp\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetch given headerhashes from the overlay. The resulting …\nFetch given header hashes from the store’s main tree. …\nFetch n hashes after given height. In the iteration, if a …\nRetrieve all headers from the store’s main tree in the …\nRetrieve all headers from the store’s sync tree in the …\nFetch the fisrt header in the store’s sync tree, based …\nFetch the last header in the store’s sync tree, based on …\nCompute the header’s hash\nBlock height\nInsert a slice of <code>Header</code> into the overlay. The header’s …\nInsert a slice of <code>Header</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>Header</code> into the store’s sync tree.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if store’s sync tree contains any records.\nRetrieve store’s sync tree records count.\nMain <code>sled</code> tree, storing all the blockchain’s blocks’ …\nOpens a new or existing <code>HeaderStore</code> on the given sled …\nThe block’s nonce. This value changes arbitrarily with …\nPrevious block hash\nRemove all records from the store’s sync tree.\nGenerate the sled batch corresponding to a remove from the …\nRemove a slice of <code>u32</code> from the store’s sync tree.\nMerkle tree root of the transactions hashes contained in …\nThe <code>sled</code> tree storing all the node pending headers while …\nBlock creation timestamp\nBlock version\nThe <code>TxStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>TxStore</code> instance.\nCheck if the store’s main tree contains a given …\nCheck if the store’s pending txs tree contains a given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetch given tx hashes from the overlay’s main tree. The …\nFetch given tx hashes from the store’s main tree. The …\nFetch n transactions after given order. In the iteration, …\nRetrieve all transactions from the store’s main tree in …\nRetrieve all transactions locations from the store’s …\nRetrieve all transactions from the store’s pending txs …\nRetrieve all transactions from the store’s pending txs …\nFetch given tx hashes locations from the store’s …\nFetch given tx hash location from the overlay’s location …\nFetch given tx hashes from the store’s pending txs tree. …\nFetch given tx hash from the overlay’s main tree. This …\nInsert a slice of <code>Transaction</code> into the overlay’s main …\nInsert a slice of <code>Transaction</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>TransactionHash</code> into the overlay’s …\nInsert a slice of <code>TransactionHash</code> into the store’s …\nInsert a slice of <code>Transaction</code> into the store’s pending …\nInsert a slice of <code>TransactionHash</code> into the store’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the store’s main tree is empty.\nRetrieve records count of the store’s main tree.\nThe <code>sled</code> tree storing the location of the blockchain’s …\nMain <code>sled</code> tree, storing all the blockchain’s …\nOpens a new or existing <code>TxStore</code> on the given sled database.\nThe <code>sled</code> tree storing all the node pending transactions, …\nThe <code>sled</code> tree storing the order of all the node pending …\nGenerate the sled batch corresponding to a remove from the …\nGenerate the sled batch corresponding to a remove from the …\nRemove a slice of <code>TransactionHash</code> from the store’s …\nRemove a slice of <code>u64</code> from the store’s pending txs order …\nClient module errors\nResult type used in the Client module\nContains the error value\nContains the error value\nGeneral library errors used throughout the codebase.\nContains the success value\nContains the success value\nMain result type used throughout the codebase.\nTransaction verification errors\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAuxiliary function to retrieve the vector of erroneous …\nAllowed timestamp drift in seconds\nAn Event Graph instance\nAtomic pointer to an <code>EventGraph</code> instance.\nGenesis event contents\nInitial genesis timestamp (07 Sep 2023, 00:00:00 UTC) Must …\nNull event ID\nThe number of parents an event is supposed to have.\nA <code>HashSet</code> containg event IDs and their 1-level parents. …\nCurrent genesis event\nSled tree containing the DAG\nFetch an event from the DAG\nAtomically insert given events into the DAG and return the …\nAtomically prune the DAG and insert the given event as …\nBackground task periodically pruning the DAG.\nSync the DAG from connected peers\nCurrently configured DAG rotation, in days\nDisable graph debugging\nEnable graph debugging\nEnable graph debugging\nSend a deg notification over the subscriber\nSubscribe to deg events\nThe subscriber for which we can give deg info over\nWe do a DFS (…\nAn event graph event\nEvent subscriber, this notifies whenever an event is …\nFind the unreferenced tips in the current DAG state, …\nReturns the argument unchanged.\nGet next layer along with its N_EVENT_PARENTS from the …\nInternal function used for DAG sorting.\nCalls <code>U::from(self)</code>.\nCreate a new <code>EventGraph</code> instance.\nPerform a topological sort of the DAG.\nPointer to the P2P network instance\nP2P protocol implementation for the Event Graph\nDAG Pruning Task\nCheck if two events have the same parents\nFlag signalling DAG has finished initial sync\nThe set of unreferenced DAG tips\nUtility functions\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of an event in the Event Graph\nReturn a reference to the event’s content\nContent of the event\nFully validate an event for the correct layout against …\nReturns the argument unchanged.\nHash the <code>Event</code> to retrieve its ID\nCalls <code>U::from(self)</code>.\nDAG layer index of the event\nCreate a new event with the given data and an [<code>EventGraph</code>] …\nParent nodes in the event DAG\nTimestamp of the event\nFully validate an event for the correct layout against …\nValidate a new event for the correct layout and enforce …\nA P2P message representing publishing an event on the …\nA P2P message representing an event reply\nA P2P message representing an event request\nMalicious behaviour threshold. If the threshold is …\nP2P protocol implementation for the Event Graph.\nTime to wait for a parent ID reply\nA P2P message representing a reply for the peer’s DAG …\nA P2P message representing a request for a peer’s DAG …\n<code>MessageSubscriber</code> for <code>TipRep</code>\nPointer to the connected peer\n<code>MessageSubscriber</code> for <code>EventPut</code>\n<code>MessageSubscriber</code> for <code>EventRep</code>\n<code>MessageSubscriber</code> for <code>EventReq</code>\nPointer to the Event Graph instance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProtocol function handling <code>EventPut</code>. This is triggered …\nProtocol function handling <code>EventReq</code>. This is triggered …\nProtocol function handling <code>TipReq</code>. This is triggered when …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nP2P jobs manager pointer\nPeer malicious message count\n<code>MessageSubscriber</code> for <code>TipReq</code>\nSeconds in a day\nCalculate the number of days since a given midnight …\nGenerate a deterministic genesis event corresponding to …\nCalculate the midnight timestamp given a number of days. …\nCalculate the timestamp of the next DAG rotation.\nCalculate the time in seconds until the next_rotation, …\nPath prefix where file chunks are stored\n<code>ChunkedFile</code> is a representation of a file we’re trying to\nPath prefix where file metadata is stored\nChunk-based file storage interface.\nDefined maximum size of a stored chunk (256 KiB)\nPath to the filesystem directory where file chunks are …\nPath to the filesystem directory where file metadata is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform garbage collection over the filesystem hierarchy. …\nFetch file metadata from Geode. Returns <code>ChunkedFile</code> which …\nFetch a single chunk from Geode. Returns a <code>PathBuf</code> …\nInsert a file into Geode. The function expects any kind of …\nCreate and insert a single chunk into Geode given a stream.\nCreate and insert file metadata into Geode given a list of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether we have all the chunks available locally.\nReturn an iterator over the chunks and their paths.\nInstantiate a new <code>Geode</code> object. <code>base_path</code> defines the root …\nAttempt to read chunk hashes from a given file path and …\nHandles the acceptance of inbound socket connections. Used …\nAsync channel that handles the sending of messages across …\nHandles the creation of outbound connections. Used to …\nOptional events based debug-notify subsystem. Off by …\nHosts are a list of network addresses used when …\nDefines how to decode generic messages as well as …\nGeneric publish/subscribe class that can dispatch any kind …\nP2P provides all core functionality to interact with the …\nDefines the networking protocol used at each stage in a …\nDefines the interaction between nodes during a connection. …\nNetwork configuration settings. This holds the configured …\nNetwork transports, holds implementations of pluggable …\nCreate inbound socket connections\nAtomic pointer to Acceptor\nRun the accept loop in a new thread and error if a …\nReturns the argument unchanged.\nHandles network errors. Panics if errors pass silently, …\nCalls <code>U::from(self)</code>.\nCreate new Acceptor object.\nRun the accept loop.\nStart accepting inbound socket connections\nStop accepting inbound socket connections\nStart receiving network messages.\nAsync channel for communication between nodes.\nChannel debug info\nAtomic pointer to async channel\nReturns the relevant socket address for this connection.  …\nBan a malicious peer and stop the channel.\nReturn the socket address without transport processing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle network errors. Panic if error passes silently, …\nChannel debug info\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun the receive loop. Start receiving messages or handle …\nReturns the inner <code>MessageSubsystem</code> reference\nThe message subsystem instance for this channel\nSets up a new channel. Creates a reader and writer <code>PtStream</code>…\nReturns a decoded Message command. We start by extracting …\nThe reading half of the transport stream\nTask that is listening for the stop signal\nReturns the socket address that has undergone transport …\nSends a message across a channel. Calls <code>send_message</code> that …\nSends an outbound Message by writing data to the given …\nWeak pointer to respective session\nSet the VersionMessage of the node this channel is …\nPerform network handshake for message subsystem …\nStarts the channel. Runs a receive loop to start receiving …\nStops the channel. Notifies all subscribers that the …\nSubscriber listening for stop signal for closing this …\nA boolean marking if this channel is stopped\nSubscribe to a message on the message subsystem.\nCreates a subscription to a stopped signal. If the channel …\nThe version message of the node we are connected to. Some …\nThe writing half of the transport stream\nCreate outbound socket connections\nEstablish an outbound connection\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new connector with given network settings\nWeak pointer to the session\nP2P settings\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHostile peers that can neither be connected to nor …\nHosts that are being connected to in Outbound and Manual …\nHosts that have been successfully connected to.\nPeers that do not match our accepted transports. We are …\nNodes to which we have already been able to establish a …\nIntermediary nodes that are periodically probed and updated\nA Container for managing Grey, White, Gold and Black …\nKeeps track of hosts and their current state. Prevents …\nHostState is a set of mutually exclusive states that can …\nMain parent class for the management and manipulation of …\nAtomic pointer to hosts object\nHosts that are currently being inserting into the hostlist.\nThe main interface for interacting with the hostlist. …\nHost that are moving between hostlists, implemented in …\nHosts that are migrating from the greylist to the …\nHosts that we have just failed to connect to. Marking a …\nRecently seen hosts. Shared with other nodes.\nIf we have the Host of the Url in the hostlist, and there …\nSubscriber for notifications of new channels\nReturns the list of connected channels.\nHostlists and associated methods.\nCheck if host is in a hostlist\nFetch addresses that match the provided transports or …\nReturn all known hosts on a hostlist.\nGet up to limit peers that don’t match the given …\nGet the oldest entry from a hostlist.\nMethod to fetch the last_seen field for a give address …\nGet up to n random peers. Schemes are not taken into …\nGet up to n random peers that don’t match the given …\nGet up to n random peers that match the given transport …\nGet a random peer from a hostlist that matches the given …\nGet up to limit peers that match the given transport …\nFilter given addresses based on certain rulesets and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the index for a given addr on a hostlist.\nGet the last_seen field for a given entry on a hostlist.\nDowngrade host to Greylist, remove from Gold or White list.\nImport blacklisted peers specified in the config file.\nSafely insert into the HostContainer. Filters the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a hostlist is empty.\nCheck whether a URL is local host\nKeeps track of the last time a connection was made.\nLoad the hostlists from a file.\nA single atomic function for moving hosts between …\nCreate a new hosts list\nRetrieve a random connected channel\nCheck whether a peer is available to be refined currently. …\nAdd a channel to the set of connected channels\nA registry that tracks hosts and their current state.\nRemove an entry from a hostlist if it exists.\nSave the hostlist to a file.\nPointer to configured P2P settings\nAppend host to a hostlist. Called when initalizing the …\nStores an address on a hostlist or updates its last_seen …\nSubscriber listening for store updates\nReturns the list of suspended channels.\nTry to update the registry. If the host already exists, …\nRemove a host from the HostRegistry. Must be called after …\nUpdate the last_seen field of a peer on a hostlist.\nSends address information to inbound connection.\nRequests address of outbound connecction.\nGeneric message template.\nOutbound keepalive message.\nInbound keepalive message.\nSends version information to inbound connection. Response …\nRequests version information of outbound connection.\nApp version\nNetwork address of the node receiving this message (before …\nExternal address of the sender node, if it exists (empty …\nList of features consisting of a tuple of (services, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of addresses with preferred transports to …\nOnly used for debugging. Compromises privacy when set.\nNetwork address of the node receiving this message (after …\nUNIX timestamp of when the VersionMessage was created.\nPreferred addresses transports\nIdentifies protocol version being used by the node\nContains the error value\nA dispatcher that is unique to every <code>Message</code>. Maintains a …\nGeneric interface for the message dispatcher.\nHandles message subscriptions through a subscription ID and\n64-bit identifier for message subscription.\nGeneric publish/subscribe class that maintains a list of …\nContains the success value\nPrivate function to concurrently transmit a message to all …\nAdd a new dispatcher for specified <code>Message</code>.\nConverts to <code>Any</code> trait. Enables the dynamic modification of …\nCleans existing items from the receiver channel.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new message dispatcher\nCreate a new message subsystem.\nTransmits a payload to a dispatcher. Returns an error if …\nCreate a random ID.\nStart receiving messages.\nStart receiving messages with timeout.\nSubscribe to a channel. Assigns a new ID and adds it to …\nSubscribes to a <code>Message</code>. Using the Message name, the method\nInternal function to deserialize data into a message type …\nInternal function that sends an error message to all …\nConcurrently transmits an error message across dispatchers.\nUnsubscribe from a channel. Removes the associated ID from …\nUnsubscribe from a message subscription. Must be called …\nToplevel peer-to-peer networking interface\nAtomic pointer to the p2p interface\nBroadcasts a message concurrently across all active …\nBroadcast a message concurrently to all given peers.\nBroadcasts a message concurrently across active channels, …\nDisable network debugging\nEnable network debugging\nEnable network debugging\nSend a dnet notification over the subscriber\nSubscribe to dnet events\nThe subscriber for which we can give dnet info over\nReference the global executor\nGlobal multithreaded executor reference\nReturns the argument unchanged.\nReturn an atomic pointer to the list of hosts\nKnown hosts (peers)\nCalls <code>U::from(self)</code>.\nInitialize a new p2p network.\nReturn a reference to the internal protocol registry\nProtocol registry\nReseed the P2P network.\nGet pointer to inbound session\nReference to configured <code>InboundSession</code>\nGet pointer to manual session\nReference to configured <code>ManualSession</code>\nGet pointer to outbound session\nReference to configured <code>OutboundSession</code>\nGet pointer to refine session\nReference to configured <code>RefineSession</code>\nReturn an atomic pointer to the set network settings\nP2P network settings\nStarts inbound, outbound, and manual sessions.\nStop the running P2P subsystem\nProtocol for address and get-address messages. Implements …\nBase trait for implementing P2P protocols\nManages the tasks for the network protocol. Used by other …\nProtocol for ping-pong keepalive messages. Implements ping …\nInterface for registering arbitrary P2P protocols\nSeed server protocol. Seed server is used when connecting …\nProtocol for version information handshake between nodes …\nRegister the default network protocols for a p2p instance.\nDefines address and get-address messages. On receiving …\nA vector of all currently accepted transports and valid …\nReturns the argument unchanged.\nHandles receiving the address message. Loops to …\nHandles receiving the get-address message. Continually …\nCreates a new address protocol. Makes an address, an …\nCalls <code>U::from(self)</code>.\nSend our own external addresses over a channel. Get the …\nStart the address protocol. If it’s an outbound session …\nPointer to protocol jobs manager\nCloses all open tasks. Takes all the tasks from the …\nReturns the argument unchanged.\nWaits for a stop signal, then closes all tasks. Ensures …\nCalls <code>U::from(self)</code>.\nCreate a new protocol jobs manager\nSpawns a new task and adds it to the internal queue\nRuns the task on an executor\nDefines ping and pong messages\nReturns the argument unchanged.\nCreate a new ping-pong protocol.\nCalls <code>U::from(self)</code>.\nWaits for ping, then replies with pong. Copies ping’s …\nRuns the ping-pong protocol. Creates a subscription to …\nStarts ping-pong keepalive messages exchange. Runs …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>ProtocolRegistry</code>\n<code>add_protocol()?</code>\nImplements the seed protocol\nReturns the argument unchanged.\nCreate a new seed protocol.\nCalls <code>U::from(self)</code>.\nSend our own external addresses over a channel. Get the …\nStarts the seed protocol. Creates a subscription to the …\nImplements the protocol version handshake sent out by …\nSend and receive version information\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new version protocol. Makes a version and version …\nReceive version info, check the message is okay and send …\nStart version information exchange. Start the timer. Send …\nSend version info and wait for version acknowledgement. …\nSession trait. Defines methods that are used across …\nBitwise selectors for the <code>protocol_registry</code>\nInbound connections session. Manages the creation of …\nManual connections session. Manages the creation of manual …\nOutbound connections session. Manages the creation of …\nReturns a pointer to the p2p network interface\nPerforms network handshake to initialize channel. Adds the …\n<code>RefineSession</code> manages two processes, the <code>GreylistRefinery</code>, …\nRegisters a new channel with the session. Performs a …\nRemoves channel from the list of connected channels when a …\nSeed sync session creates a connection to the seed nodes …\nReturn the session bit flag for the session type\nDefines inbound connections session\nWait for all new channels created by the acceptor and call …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new inbound session\nRegisters the channel. First performs a network handshake …\nStarts the inbound session. Begins by accepting …\nStart accepting connections for inbound session.\nStops the inbound session.\nDefines manual connections session.\nCreates a connector object and tries to connect using it\nConnect the manual session to the given address\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new manual session.\nStops the manual session.\nHighest preference that corresponds to the …\nLowest preference if we still haven’t been able to find …\nDefines outbound connections session.\nMain PeerDiscovery process that loops through connected …\nDefines a common interface for multiple peer discovery …\nReduced preference in case we don’t have sufficient …\nAddress selection algorithm that works as follows: up to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new outbound session.\nWakeup peer discovery by sending a notification to …\nWeak pointer to parent p2p object\nPeer discovery task\nActivate peer discovery if not active already. For the …\nOutbound connection slots\nStart the outbound session. Runs the channel connect loop.\nStops the outbound session.\nStart making an outbound connection, using provided …\nBlocks execution until we receive a notification from …\nPeriodically probes entries in the greylist.\nPeriodically try to do a version exchange with our own …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobally accessible function to perform a version exchange …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWeak pointer to parent p2p object\nTask that periodically checks entries in the greylist.\nTask that periodically checks our external addresses.\nWeak pointer to parent object\nStart the refinery and self handshake processes.\nStop the refinery and self handshake processes.\nDefines seed connections session\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new seed sync session instance\nStart the seed sync session. Creates a new task for every …\nConnects to a seed socket address\nP2P network settings. The scope of this is a P2P network …\nDefines the network settings.\nAtomic pointer to network settings\nWhitelisted network transports for outbound connections\nPreferred transports for outbound connections\nNumber of anchorlist connections\nNumber of anchorlist connections\nApplication version, used for convenient protocol matching\nNodes to avoid interacting with for the duration of the …\nNodes to avoid interacting with for the duration of the …\nExchange versions (handshake) timeout (in seconds)\nExchange versions (handshake) timeout in seconds\nPing-pong exchange execution interval (in seconds)\nPing-pong exchange execution interval in seconds\nP2P external addresses the instance advertises so other …\nP2P external addresses node advertises so other peers can …\nReturns the argument unchanged.\nReturns the argument unchanged.\nPause interval within greylist refinery process\nPause interval within greylist refinery process\nHostlist storage path\nHosts .tsv file to use\nP2P accept address node listens to for inbound connections\nP2P accept addresses the instance listens on for inbound …\nInbound connection slots number, this many active …\nInbound connection slots number\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllow localnet hosts\nAllow localnet hosts\nOnly used for debugging, compromises privacy when set\nOnly used for debugging. Compromises privacy when set.\nOutbound connection timeout (in seconds)\nConnection establishment timeout in seconds\nOutbound connection slots number, this many connections …\nOutbound connection slots number\nTime between peer discovery attempts\nTime between peer discovery attempts\nCooling off time for peer discovery when unsuccessful\nCooling off time for peer discovery when unsuccessful\nPeer nodes to manually connect to\nPeer nodes to manually connect to\nSeed nodes to connect to for peer discovery and/or …\nSeed nodes to connect to for peers retrieval and/or …\nPause interval before redoing a self-handshake\nPause interval before redoing a self-handshake\nNumber of seconds with no connections after which refinery …\nNumber of seconds with no connections after which refinery …\nAllow transport mixing (e.g. Tor would be allowed to …\nAllow transport mixing (e.g. Tor would be allowed to …\nPercent of connections to come from the whitelist\nNumber of whitelist connections\nA dialer that is able to transparently operate over …\nDialer variants\nA listener that is able to transparently listen over …\nListener variants\nNym\nNym with TLS\nWrapper trait for async listeners\nWrapper trait for async streams\nPlain TCP\nPlain TCP\nTCP with TLS\nTCP with TLS\nTor\nTor with TLS\nUnix socket\nUnix socket\nDial an instantiated <code>Dialer</code>. This creates a connection and …\nReturn a reference to the <code>Dialer</code> endpoint\nThe endpoint to connect to\nThe address to open the listener on\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nListen on an instantiated <code>Listener</code>. This will open a …\nInstantiate a new <code>Dialer</code> with the given <code>Url</code>.\nInstantiate a new <code>Listener</code> with the given <code>Url</code>. Must …\nNym transport\nTCP transport\nTLS upgrade mechanism\nTor transport\nUnix socket transport\nThe dialer variant (transport protocol)\nThe listener variant (transport protocol)\nUnique, randomly-generated per-connection ID that’s used …\nNym Dialer implementation\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>NymDialer</code> object\nTCP Dialer implementation\nTCP Listener implementation\nSize of the listen backlog for listen sockets\nInternal helper function to create a TCP socket.\nInternal helper function to create a TCP socket.\nInternal dial function\nInternal listen function\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>TcpDialer</code> with optional TTL.\nInstantiate a new <code>TcpListener</code> with given backlog size.\nTTL to set for opened sockets, or <code>None</code> for default.\nTLS client configuration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTLS server configuration\nValidate certificate DNSName.\nA static for <code>TorClient</code> reusability\nTor Dialer implementation\nInternal dial function\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>TorDialer</code> object\nUnix Dialer implementation\nUnix Listener implementation\nInternal dial function\nInternal listen function\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>UnixDialer</code> object\nInstantiate a new <code>UnixListener</code> object\nClient-side JSON-RPC implementation\nClock sync utility module Clock sync module\nCommon internal functions\nVarious <code>From</code> implementations\nJSON-RPC primitives JSON-RPC 2.0 object definitions\nProvides optional <code>p2p.get_info()</code> method\nServer-side JSON-RPC implementation\nJson helper methods and types\nHighly experimental JSON-RPC client implementation using …\nJSON-RPC client implementation using asynchronous channels.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new JSON-RPC client that connects to the …\nInstantiate a new JSON-RPC client that connects to the …\nOneshot send a given JSON-RPC request over the …\nThe channel used to read the JSON-RPC response object.\nThe channel used to read the JSON-RPC response object\nThe channel used to send JSON-RPC request objects. The <code>bool</code>…\nThe channel used to send JSON-RPC request objects\nThe channel used to skip waiting for a JSON-RPC client …\nInternal function that loops on a given stream and …\nInternal function that loops on a given stream and …\nSend a given JSON-RPC request over the instantiated client …\nSend a given JSON-RPC request over the instantiated client …\nStop the JSON-RPC client. This will trigger <code>stop()</code> on the …\nStop the JSON-RPC client. This will trigger <code>stop()</code> on the …\nListen instantiated client for notifications. NOTE: …\nThe stoppable task pointer, used on <code>RpcClient::stop()</code>\nThe stoppable task pointer, used on <code>RpcChadClient::stop()</code>\nTODO: Loop through set of ntps, get their average response …\nClock sync parameters\nThis is a very simple check to verify that the system time …\nRaw NTP request execution\nInternal read function that reads from the active stream …\nInternal write function that writes a JSON-RPC object to …\nJSON-RPC error codes. The error codes <code>[-32768, -32000]</code> are …\nID mismatch\nInternal JSON-RPC error.\nInvalid method parameter(s).\nInvalid/Unexpected reply\nThe JSON sent is not a valid Request object.\nA JSON-RPC error object\nA JSON-RPC error value (code and message)\nA JSON-RPC notification object\nA JSON-RPC request object\nA JSON-RPC response object\nWrapping enum around the available JSON-RPC object types\nA JSON-RPC subscriber for notifications\nThe method does not exist / is not available.\nInvalid JSON was received by the server. An error occurred …\nReserved for implementation-defined server-errors.\nSubscriber is a special object that yields a channel\nError code\nJSON-RPC error (code and message)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRequest ID\nRequest ID\nRequest ID\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJSON-RPC version\nJSON-RPC version\nJSON-RPC version\nJSON-RPC version\nError message\nRequest method\nNotification method\nNotification method\nCreate a new <code>JsonRequest</code> object with the given method and …\nCreate a new <code>JsonNotification</code> object with the given method …\nCreate a new <code>JsonResponse</code> object with the given ID and …\nCreate a new <code>JsonError</code> object with the given error code, …\nSend a notification to the subscriber with the given JSON …\nRequest parameters\nNotification parameters\nResponse result\nConvert the object into a JSON string\nConvert the object into a JSON string\nConvert the object into a JSON string\nConvert the object into a JSON string\nNotification subscriber\nAsynchronous trait implementing a handler for incoming …\nAccept function that should run inside a loop for …\nStart a JSON-RPC server bound to the given accept URL and …\nWrapper function around <code>accept()</code> to take the incoming …\nArray type value.\nBoolean type value.\nEnum to represent one JSON value. Each variant represents …\nNull type value.\nNumber type value.\nObject type value.\nString type value.\nConvert this JSON value to <code>String</code> value with 2-spaces …\nWrite this JSON value to the given <code>io::Write</code> object as …\nReturns the argument unchanged.\nGet immutable reference to the inner value.\nGet mutable reference to the inner value.\nCalls <code>U::from(self)</code>.\nCheck if the inner value is an array.\nCheck if the inner value is a boolean.\nCheck if the inner value is null.\nCheck if the inner value is a number.\nCheck if the inner value is an object.\nCheck if the inner value is a string.\nConvert this JSON value to <code>String</code> value.\nWrite this JSON value to the given <code>io::Write</code> object as …\nImported WASM host functions\nVM memory access (read/write)\nMain WASM VM runtime implementation\nAccess control for host functions\nHost functions for interacting with db backend\nHost functions for merkle tree functions\nHost functions for sparse merkle tree functions\nHost functions for utilities\nReturn an error if the current Env section is not in the …\nInternal wasm runtime API for sled trees\nCheck if a database contains a given key.\nRemove a key from the database.\nReads a value by key from the key-value store.\nCreate a new database instance for the calling contract.\nLookup a database handle from its name. If it exists, push …\nSet a value within the transaction.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a zkas circuit, create a VerifyingKey and insert …\nAdds data to merkle tree. The tree, database connection, …\nAn SMT adapter for sled overlay storage. Compatible with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAdds data to sparse merkle tree. The tree, database …\nHost function for logging strings.\nWill return current blockchain timestamp, defined as the …\nWill return current runtime configured verifying block …\nGrabs last block from the <code>Blockchain</code> overlay and then …\nRetrieve an object from the object store specified by the …\nReturns the size (number of bytes) of an object in the …\nReads a transaction by hash from the transactions store.\nWill return current runtime configured transaction hash\nReads a transaction location by hash from the transactions …\nWill return current runtime configured verifying block …\nWrites data to the <code>contract_return_data</code> field of <code>Env</code>. The …\nSetup function of a contract\nThe WASM VM runtime environment instantiated for every …\nEntrypoint function of a contract\nGas limit for a single contract call (Single WASM instance)\nName of the wasm linear memory in our guest module\nMetadata\nPlaceholder state before any initialization\nDefine a wasm runtime.\nApply function of a contract\nThis function runs after successful execution of <code>exec</code> and …\nBlockchain overlay access\nCall a contract method defined by a <code>ContractSection</code> using …\nThe index for this call in the transaction\nThe compiled wasm bincode being executed,\nThe contract ID being executed\nState update produced by a smart contract function call\nThe contract section being executed\nCopy payload to the start of the memory\nOverlay tree handles used with <code>db_*</code>\nThis function runs when a smart contract is initially …\nThis function runs when someone wants to execute a smart …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculate the remaining gas using wasm’s concept of …\nParent <code>Instance</code>\nA wasm instance\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLogs produced by the contract\nGet memory, that needs to have been set fist\nDirect memory access to the VM\nProvide safe access to the memory (it must be initialized …\nThis function runs first in the entire scheme of executing …\nCreate a new wasm runtime instance that contains the given …\nObject store for transferring memory from the host to VM\nPrints the wasm contract logs.\nSerialize contract payload to the format accepted by the …\nSet the memory page size. Returns the previous memory size.\nA wasm store (global state)\nSubtract given gas cost from remaining gas in the current …\nTake Memory by value. Needed to modify the Memory object …\nThe hash for this transaction the runtime is being run …\nBlock height number runtime verifies against. For …\nCondition variable which allows a task to block until …\nConvenient late initialization of <code>Weak&lt;Foo&gt;</code>\nSleep for any number of milliseconds.\nRun a task until it has fully completed, irrespective of …\nSleep for any number of seconds.\nImplementation of async background task spawning which are …\nSimple broadcast (publish-subscribe) class\nAsync timeout implementations\nCondition variables allow you to block a task while …\nAwaitable futures object returned by <code>condvar.wait()</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWakeup the waiting task. Subsequent calls to this do …\nReset self ready to wait() again. The reason this is …\nReset the condition variable and wait for a notification\nSometimes you need a parent-child relationship which …\nReturns the argument unchanged.\nMust be called within the same scope as <code>new()</code>.\nCalls <code>U::from(self)</code>.\nCreate an empty <code>LazyWeak</code>, which must immediately be …\nAccess the <code>Arc&lt;Parent&gt;</code> pointer\nWhen we call <code>stop()</code>, we wait until the process is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUsed to signal to the main running process that it should …\nStarts the task.\nStops the task. On completion, guarantees the process has …\nUsed so we can keep StoppableTask in HashMap/HashSet\nSimple broadcast (publish-subscribe) class.\nSubscription to the Subscriber. Created using …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new subscriber.\nPublish a message to all listening subscriptions.\nPublish a message to all listening subscriptions but …\nReceive message.\nMake sure you call this method early in your setup. That …\nMust be called manually since async Drop is not possible …\nAn error returned when a future times out.\nA future that times out after a duration of time.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAwaits an I/O future or times out after a duration of time.\nAwaits a future or times out after a duration of time.\nAuxiliarry structure containing all the information …\nCalls tree bounds definitions\nA Transaction contains an arbitrary number of <code>ContractCall</code> …\nAuxiliary structure to build a full <code>Transaction</code> using …\nAppend a new call tree to the forest\nBuilder builds the calls vector using the <code>DarkForest</code> and …\nCall executed\nContract calls trees forest\nCalls executed in this transaction\nCreate Schnorr signatures for the entire transaction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the transaction hash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize the builder, using provided data to generate …\nAttached ZK proofs\nAttached ZK proofs\nAttached Schnorr signatures\nVerify Schnorr signatures for the entire transaction.\nVerify ZK proofs for the entire transaction.\nCommand-line interface utilities\nVarious encoding formats\nFilesystem utilities\nParsing helpers\nFilesystem path utilities\nPermuted Congruential Generator (PCG) This is an insecure …\nRing Buffer implementation\nTime utilities\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBase32 encoding and decoding Base32 encoding as specified …\nBase64 encoding and decoding\nStandard Base32 alphabet.\nTries to decode a base32 string into a byte vector. …\nEncode a byte slice with the given base32 alphabet into a …\nTries to decode a base64 string into a byte vector. …\nEncode a byte slice into a base64 string\nReturns <code>$XDG_CONFIG_HOME</code>, <code>$HOME/.config</code>, or <code>None</code>.\nReturns the path to the user’s home directory. Use <code>$HOME</code>…\nGet the home directory from the passwd entry of the …\nJoin a path with <code>config_dir()/darkfi</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA ring buffer of fixed capacity\nProvides a reference to the back element, or <code>None</code> if empty.\nReturns true if the buffer contains an element equal to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if buffer is empty, false otherwise\nReturns a front-to-back iterator\nReturns the current number of items in the buffer\nRearranges the internal storage of this deque so it is one …\nCreate a new <code>RingBuffer</code> with given fixed capacity\nRemoves and returns the oldest item in the buffer\nPush an element to the back of the <code>RingBuffer</code>, removing …\nCast the ringbuffer into a vec\nWrapper struct to represent system timestamps.\nAdd <code>self</code> to a given timestamp Errors on integer overflow.\nSubtract <code>self</code> with a given timestamp Errors on integer …\nGenerate a <code>Timestamp</code> of the current time.\nCalculates the elapsed time of a <code>Timestamp</code> up to the time …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the inner <code>u64</code> of <code>Timestamp</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis struct represents a DarkFi validator node.\nConfiguration for initializing <code>Validator</code>\nAtomic pointer to validator.\nApply provided set of <code>BlockInfo</code> without doing formal …\nValidate a set of <code>BlockInfo</code> in sequence and apply them if …\nValidate a producer <code>Transaction</code> and apply it if valid. In …\nValidate a set of <code>Transaction</code> in sequence and apply them …\nThe node locks its consensus state and tries to append …\nThe node retrieves a transaction, validates its state …\nCanonical (finalized) blockchain\nAuxiliary function to compute provided transaction’s …\nDarkFi consensus module\nHot/Live data used by the consensus algorithm\nFee calculation helpers\nThe node checks if best fork can be finalized. If …\nCurrently configured finalization security threshold\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenesis block\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDarkFi PoW module\nOptional fixed difficulty, for testing purposes\nCurrently configured PoW target\nThe node removes invalid transactions from the pending txs …\nFlag signalling node has finished initial sync\nHelper utilities\nRetrieve all existing blocks and try to apply them to an …\nVerification functions\nFlag to enable tx fee verification\nFlag to enable tx fee verification\nThis struct represents the information required by the …\nThis struct represents a forked blockchain state, using an …\nThis struct represents a block proposal, used for …\nBlock/proposal maximum transactions, exluding producer …\nLock to restrict when proposals appends can happen\nGiven a proposal, the node verifys it and finds which fork …\nAuxiliary function to append a proposal and update current …\nAuxiliary function to retrieve current best fork last …\nBlock data\nCanonical (finalized) blockchain\nCanonical (finalized) blockchain\nFork proposal overlay diffs sequence\nCheck if best fork proposals can be finalized. Consensus …\nFork size(length) after which it can be finalized\nGiven a proposal, find the fork chain it extends, and …\nFork chains containing block proposals\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAuxiliary function to create a full clone using …\nGenerate a new empty fork.\nAuxiliary function to retrieve current best fork proposals.\nAuxiliary function to retrieve a fork proposals. If …\nAuxiliary function to compute forks’ next block height.\nBlock hash\nCurrent fork hashes rank, cached for better performance\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAuxiliary function to retrieve last proposal.\nValid pending transaction hashes\nCanonical blockchain PoW module state\nCurrent PoW module state,\nGenerate a new Consensus state.\nOverlay cache over canonical Blockchain\nFork proposal hashes sequence\nAuxiliary function to purge current forks and reset the …\nCurrent fork mining targets rank, cached for better …\nAuxiliary function to retrieve unproposed valid …\nFixed fee for verifying Schnorr signatures using the …\nCalculate the gas use for verifying a given zkas circuit. …\nHow many most recent blocks to use to verify new blocks’ …\nTime limit in the future of what blocks can be\nRing buffer length. Must be == DIFFICULTY_WINDOW + …\nAlready known cutoff start index for this config\nAlready known cutoff end index for this config\nAmount of max items(blocks) to use for next difficulty …\nThis struct represents the information required by the PoW …\nMax items to use for next difficulty calculation. Must be …\nUsed to calculate how many items to retain for next …\nAmount of latest blocks to exlude from the calculation. …\nAppend provided timestamp and difficulty to the ring …\nAppend provided block difficulty to the ring buffers and …\nTotal blocks cummulative difficulty Note: we keep this as …\nCalculate cutoff indexes. If buffers have been filled, we …\nLatest block cummulative difficulties ringbuffer\nOptional fixed difficulty\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMine provided block, based on provided PoW module next …\nMine provided block, based on next mine target\nCompute the next mining difficulty, based on current ring …\nCompute the next mine target\nCompute the next mine target and difficulty\nTarget block time, in seconds\nLatest block timestamps ringbuffer\nVerify provided block corresponds to next mine target\nVerify provided block timestamp and hash\nVerify provided block timestamp is not far in the future …\nVerify provided difficulty corresponds to the next one\nVerify provided block timestamp is valid and matches …\nAuxiliary function to find best ranked fork. The best …\nCompute a block’s rank, assuming that its valid, based …\nDeploy DarkFi native wasm contracts to provided blockchain …\nGiven a proposal, find the index of a fork chain it …\nAuxiliary function to calculate the middle value between …\nAuxiliary function to calculate the median of a given …\nApply given producer <code>Transaction</code> to the provided overlay, …\nApply given <code>Transaction</code> to the provided overlay. …\nApply given set of <code>Transaction</code> in sequence, without formal …\nA block is considered valid when the following rules apply:\nA blockchain is considered valid, when every block is …\nVerify given <code>BlockInfo</code>, and apply it to the provided …\nVerify given checkpoint <code>BlockInfo</code>, and apply it to the …\nVerify given genesis <code>BlockInfo</code>, and apply it to the …\nVerify block proposer signature, using the producer …\nVerify WASM execution, signatures, and ZK proofs for a …\nVerify given <code>Proposal</code> against provided consensus state, A …\nVerify WASM execution, signatures, and ZK proofs for a …\nVerify a set of <code>Transaction</code> in sequence and apply them if …\nExport witness.json which can be used by zkrunner for …\nZK gadget implementations\nImport witness.json which can be used to debug or …\nProof creation API\nTrace computation of intermediate values in circuit\nHalo2 zkas virtual machine\nVM heap variable definitions and utility functions VM heap …\nCall this before <code>Proof::create()</code> to perform type checks on …\nExport witness.json which can be used by zkrunner for …\nImport witness.json which can be used to debug or …\nCall this before <code>Proof::create()</code> to perform type checks on …\nBase field arithmetic gadget\nConditional selection\nis_equal comparison gadget\nis_zero comparison gadget\nField-native less than comparison gadget with a lookup …\nField-native range check gadget with a lookup table\nSmall range check, 0..8 bits\nPoseidon-based sparse Merkle tree chip\nConditional selection based on lhs (will output lhs if …\nArithmetic Chip\nConfiguration for the Arithmetic Chip\nArithmetic instructions implemented in the chip\nlhs\nAdd two field elements and return their sum\nrhs\nout\nConfigure the Arithmetic chip with the given columns\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMultiply two field elements and return their product\nSelector for the <code>add</code> operation\nSelector for the <code>mul</code> operation\nSelector for the <code>sub</code> operation\nSubtract two field elements and return their difference\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the main chip function. Attempts to witness the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>k_values_table</code> should be reused across different chips …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that an expression is in the small range [0..range),\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfigure the chip.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn advice column\nA value assigned to a cell within a circuit.\nAn assigned cell.\nA column with an index and type\nThis trait represents an element of a field.\nA layout strategy within a circuit. The layouter is …\nThe one element of the field, the multiplicative identity.\nA value stored as a fraction to enable batch inversion.\nRepresents the type of the “root” of this layouter, so …\nA value that does not require inversion to evaluate.\nA value that might exist within a circuit.\nThe zero element of the field, the additive identity.\nThe field element zero.\nReturns <code>Value::unknown()</code> if the value is <code>Value::unknown()</code>, …\nConverts from <code>&amp;mut Value&lt;V&gt;</code> to <code>Value&lt;&amp;mut V&gt;</code>.\nConverts from <code>&amp;Value&lt;V&gt;</code> to <code>Value&lt;&amp;V&gt;</code>.\nEnforces an assertion on the contained value, if known.\nAssign a region of gates to an absolute row number.\nAssign a table region to an absolute row number.\nReturns the cell.\nMaps a <code>Value&lt;&amp;V&gt;</code> to a <code>Value&lt;V&gt;</code> by cloning the contents of …\nMaps a <code>Value&lt;&amp;mut V&gt;</code> to a <code>Value&lt;V&gt;</code> by cloning the contents …\nType of this column.\nConstrains a <code>Cell</code> to equal an instance column’s row …\nMaps a <code>Value&lt;&amp;mut V&gt;</code> to a <code>Value&lt;V&gt;</code> by copying the contents …\nMaps a <code>Value&lt;&amp;V&gt;</code> to a <code>Value&lt;V&gt;</code> by copying the contents of …\nCopies the value to a given advice cell and constrains …\nCubes this element.\nCubes this field element.\nCubes this element.\nReturns the denominator, if non-trivial.\nTools for developing circuits.\nDoubles this element.\nDoubles this field element.\nDoubles this element.\nChecks the contained value for an error condition, if …\nEvaluates this value directly, performing an unbatched …\nEvaluates this assigned cell’s value directly, …\nEvaluates this assigned value directly, performing an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code>: if it is …\nGets the “root” of this assignment, bypassing the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the field element corresponding to this value.\nComputes the multiplicative inverse of this element, …\nInverts this assigned value (taking the inverse of zero to …\nInverts this assigned value (taking the inverse of zero to …\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nConstructs a known value.\nMaps a <code>Value&lt;V&gt;</code> to <code>Value&lt;W&gt;</code> by applying a function to the …\nEnters into a namespace.\nReturns the numerator.\nThis module provides an implementation of a variant of …\nExits out of the existing namespace.\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nCreates a new (sub)namespace and enters into it.\nReturns an element chosen uniformly at random using a …\nReturns the square root of the field element, if it is …\nEquivalent to <code>Self::sqrt_ratio(self, one())</code>.\nComputes:\nSquares this element.\nSquares this field element.\nSquares this element.\nReturns the field element corresponding to this value.\nTransposes a <code>Value&lt;[V; LEN]&gt;</code> into a <code>[Value&lt;V&gt;; LEN]</code>.\nTransposes a <code>Value&lt;impl IntoIterator&lt;Item = V&gt;&gt;</code> into a …\nConstructs an unwitnessed value.\nUnzips a value containing a tuple of two values.\nReturns the value of the <code>AssignedCell</code>.\nReturns the field element value of the <code>AssignedCell</code>.\nZips <code>self</code> with another <code>Value</code>.\nA cell used in an active gate was not assigned to.\nMeasures a circuit to determine its costs, and explain …\nA struct for collecting and displaying the gates within a …\nGraphical renderer for circuit layouts.\nA constraint was not satisfied for a particular row.\nA constraint was active on an unusable row, and is likely …\nThe location within the circuit at which a particular …\nA location inside a region.\nAn instance cell used in an active gate was not assigned …\nA lookup input did not exist in its corresponding table.\nA test prover for debugging circuits.\nA location outside of a region.\nA permutation did not preserve the original value of a …\nA helper type that augments a <code>FloorPlanner</code> with <code>tracing</code> …\nThe reasons why a particular circuit is not satisfied.\nPanics if the circuit being checked by this <code>MockProver</code> is …\nBuilds a dot graph string representing the given circuit.\nCollects the gates from within the circuit.\nDeveloper tools for investigating the cost of a circuit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the marginal proof size per instance of this …\nMarks cells involved in equality constraints, in red.\nMeasures a circuit with parameter constant <code>k</code>.\nMetadata about circuits.\nReturns the proof size for the given number of instances …\nPrints the queries in this circuit to a CSV grid.\nRenders the given circuit on the given drawing area.\nRuns a synthetic keygen-and-prove operation on the given …\nDraws red lines between equality-constrained cells.\nSets the visibility of region labels.\nReturns <code>Ok(())</code> if this <code>MockProver</code> is satisfied, or a list …\nSets the view height for this layout, as a number of rows.\nSets the view width for this layout, as a number of …\nThe offset (relative to the start of the region) at which …\nThe region in which the failure occurred.\nThe circuit row on which the failure occurred.\nThe values of the virtual cells used by this constraint.\nThe column in which this cell should be assigned.\nThe column in which this cell should be assigned.\nThe column in which this permutation is not satisfied.\nThe polynomial constraint that is not satisfied.\nThe polynomial constraint that is not satisfied.\nThe index of the active gate.\nThe index of the active gate.\nThe offset (relative to the start of the region) at which …\nThe offset (relative to the start of the region) at which …\nThe location at which this constraint is not satisfied.\nThe location at which the lookup is not satisfied.\nThe location at which the permutation is not satisfied.\nThe index of the lookup that is not satisfied. These …\nThe offset (relative to the start of the region) at which …\nThe region in which this cell should be assigned.\nThe region in which this gate was activated.\nThe absolute row at which this cell should be assigned.\nMeasures a circuit to determine its costs, and explain …\nThe marginal size of a Halo 2 proof, broken down into its …\nThe size of a Halo 2 proof, broken down into its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMetadata about a column within a circuit.\nMetadata about a configured constraint within a circuit.\nMetadata about a configured gate within a circuit.\nMetadata about an assigned region within a circuit.\nA “virtual cell” is a PLONK cell that has been queried …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn advice column\nAn Advice variant\nThis is an advice (witness) column queried at a certain …\nQuery of advice column at a certain relative location\nAn enum over the Advice, Fixed, Instance structs\nA value assigned to a cell within a circuit.\nThis trait allows a <code>Circuit</code> to direct some backend to …\nA verifier that checks multiple proofs in a batch. <strong>This </strong>…\nOut of bounds index passed to a backend\nThis is a trait that circuits provide implementations for …\nA column with an index and type\nA <code>TableColumn</code> has not been assigned.\nThe instance sets up a copy constraint involving a column …\nA column type\nThis is a configuration object that stores things like …\nThis is a constant polynomial\nAn individual polynomial constraint.\nThis is a description of the circuit environment, such as …\nThe constraint system is not satisfied.\nA set of polynomial constraints with a common selector.\nThis is an error that could occur during proving or …\nLow-degree expression representing an identity that must …\nA fixed column\nA Fixed variant\nThis is a fixed column queried at a certain relative …\nQuery of fixed column at a certain relative location\nA floor planning strategy for a circuit.\nThe floor planner used for this circuit. This is an …\nGate\nAn instance column\nAn Instance variant\nThis is an instance (external) column queried at a certain …\nQuery of instance column at a certain relative location\nInstance provided exceeds number of available rows\nThe provided instances do not match the circuit parameters.\nThis is a negated polynomial\nCircuit synthesis requires global constants, but circuit …\n<code>k</code> is too small for the given circuit.\nOpening error\nThe output type of this verification strategy after …\nAttempt to overwrite a default value\nOptional circuit configuration parameters. Requires the …\nRepresents the minimal parameters that determine a …\nMinimal representation of a verification key that can be …\nThis is the product of two polynomials\nThis is a proving key which allows for the creation of …\nA value stored as a fraction to enable batch inversion.\nThis is a scaled polynomial\nA selector, representing a fixed boolean value per row of …\nThis is a virtual selector\nA verifier that checks a single proof at a time.\nThis is the sum of two polynomials\nThis is an error that can occur during synthesis of the …\nA fixed column of a lookup table.\nThis is an error that could occur during table synthesis.\nAn error relating to a lookup table.\nTranscript error\nA value that does not require inversion to evaluate.\nA Table has columns of uneven lengths.\nAttempt to assign a used <code>TableColumn</code>\nTrait representing a strategy for verifying Halo 2 proofs.\nThis is a verifying key which allows for the verification …\nExposes the “virtual cells” that can be queried while …\nThe field element zero.\nAdds a proof to the batch.\nAllocate a new advice column\nAssign an advice column value (witness)\nAssign a fixed value\nCompute the number of blinding factors necessary to …\nAllocate a new complex selector that can appear anywhere …\nThe circuit is given an opportunity to describe the exact …\nThe circuit is given an opportunity to describe the exact …\nReturn the constraint name\nAssign two cells to have the same value\nCreates a new gate.\nThis creates a proof for the provided <code>circuit</code> when given …\nCompute the degree of this polynomial\nCompute the degree of the constraint system (the maximum …\nEnable this selector at the given offset within the given …\nEnables this fixed column to be used for global constant …\nEnable equality on this TableColumn.\nEnable the ability to enforce equality over cells in this …\nEnables a selector at the given row.\nCreates a new region and enters into it.\nEvaluate the polynomial using the provided closures to …\nExits the current region.\nFills a fixed <code>column</code> starting from the given <code>row</code> with …\nFinalizes the batch and checks its validity.\nAllocate a new fixed column\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads a verification key from a slice of bytes using …\nReads a proving key from a slice of bytes using <code>Self::read</code>.\nReturn <code>self.advice_queries</code>\nReturn <code>self.constants</code>\nGet the underlying <code>EvaluationDomain</code>.\nReturn <code>self.fixed_queries</code>\nReturn <code>self.gates</code>\nReturn <code>self.instance_queries</code>\nReturn <code>self.lookups</code>\nReturn <code>self.minimum_degree</code>\nReturn <code>self.num_advice_columns</code>\nReturn <code>self.num_advice_queries</code>\nReturn <code>self.num_fixed_columns</code>\nReturn <code>self.num_instance_columns</code>\nReturn <code>self.num_selectors</code>\nReturn <code>self.permutation</code>\nReturn <code>self.selector_map</code>\nGet the underlying <code>VerifyingKey</code>.\nHashes a verification key into a transcript.\nAllocate a new instance column\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this selector “simple”? Simple selectors can only …\nGenerate a <code>ProvingKey</code> from a <code>VerifyingKey</code> and an instance …\nGenerate a <code>VerifyingKey</code> from an instance of <code>Circuit</code>.\nAdd a lookup argument for some input expressions and table …\nAllocates a new fixed column that can be used in a lookup …\nReturns the minimum necessary rows that need to exist in …\nReturn the gate name\nConstructs a new batch verifier.\nConstructs a new single proof verifier.\nReturns a reference to the parameters that should be used …\nObtain a pinned version of this constraint system; a …\nObtains a pinned representation of this verification key …\nReturn the gate polynomials\nExits out of the existing namespace.\nObtains an MSM from the verifier strategy and yields back …\nCreates a new (sub)namespace and enters into it.\nReturn the queried selectors in the gate\nQuery an advice column at a relative position\nQuery an Any column at a relative position\nQuery a fixed column at a relative position\nQueries the cell of an instance column at a particular …\nQuery an instance column at a relative position\nQuery a selector at the current position.\nReads a verification key from a buffer.\nReads a proving key from a buffer. Does so by reading …\nAllocate a new (simple) selector. Simple selectors cannot …\nSets the minimum degree required by the circuit, which can …\nSquare this expression.\nGiven the provided <code>cs</code>, synthesize the given circuit.\nGiven the provided <code>cs</code>, synthesize the circuit. The …\nWrites a verifying key to a vector of bytes using …\nWrites a proving key to a vector of bytes using <code>Self::write</code>…\nReturns a boolean indicating whether or not the proof is …\nConstructs a set of constraints that are controlled by the …\nReturns a copy of this circuit with no witness values …\nWrites a verifying key to a buffer.\nWrites a proving key to a buffer.\nThe current value of <code>k</code> being used.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a hex formatted string of the data (big endian)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBase field arithmetic chip\nBoolean check\nConditional selection\nECC Chip\n253 bit <code>a &lt; b</code> check\nMerkle tree chip (using Sinsemilla)\n253 bit native range check\n64 bit native range check\nPoseidon hash chip\nSinsemilla chip\nSparse merkle tree (using Poseidon)\nAvailable chips/gadgets in the zkvm\nzkvm configuration\nZero-Cond selection\nConfiguration parameters for the circuit. Defines which …\nChips used in the circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstance column used for public inputs\nAdvice column used to witness values\nThese represent the witness types inside the circuit\nThese represent the witness types outside of the circuit\nHelper function for verifiers to generate empty witnesses …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAnalyzer module\nLanguage AST\nCompiler module\nConstants\nDecoder module\nError emitter\nLexer module\nLanguage opcodes\nParser module\nLanguage types\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVersion of the binary\nMagic bytes prepended to the binary\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllowed fields for proofs\nMaximum allowed k param (circuit rows = 2^k)\nMaximum allowed namespace length in bytes\nMinimum size allowed for a syntactically valid ZkBinary …\nA ZkBinary decoded from compiled zkas code. This is used …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBase field element addition\nBase field element multiplication\nBase field element subtraction\nCheck if a field element fits in a boolean (Either 0 or 1)\nConditionally select between two base field elements given …\nConstrain equality of two Base field elements inside the …\nConstrain equality of two EcPoint elements inside the …\nConstrain a Base field element to a circuit’s public …\nDebug a variable’s value in the ZK circuit table.\nElliptic curve addition\nGet the x coordinate of an elliptic curve point\nGet the y coordinate of an elliptic curve point\nElliptic curve multiplication\nElliptic curve multiplication with a Base field element\nElliptic curve multiplication with a Base field element of …\nVariable Elliptic curve multiplication with a Base field …\nLoosely two Base field elements and see if a is less than b\nStrictly compare two Base field elements and see if a is …\nCalculate Merkle root, given a position, Merkle path, and …\nIntermediate opcode for the compiler, should never appear …\nOpcodes supported by the zkas VM\nPoseidon hash of N Base field elements\nRange check a Base field element, given bit-width (up to …\nCalculate sparse Merkle root, given the position, path and …\nWitness an unsigned integer into a Base field element\nConditionally select between a and b (return a if a is …\nReturn a tuple of vectors of types that are accepted by a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nzkas language builtin keywords. These can not be used …\nForbidden namespaces\nValid EcFixedPoint constant names supported by the VM.\nValid EcFixedPointBase constant names supported by the VM.\nValid EcFixedPointShort constant names supported by the VM.\nRoutine checks on section structure\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCatch-all for any type\nBase field element\nBase field element array\nDummy intermediate type\nDummy intermediate type\nElliptic curve fixed point (a constant)\nElliptic curve fixed point in base field\nElliptic curve fixed point short\nElliptic curve nonidentity point\nElliptic curve point\nHeap types in bincode &amp; vm\nLiteral types supported by the zkas VM\nMerkle tree path\nScalar field element\nScalar field element array\nSparse merkle tree path\nUnsigned 32-bit integer\nUnsigned 64-bit integer\nUnsigned 64-bit integer\nVarable types supported by the zkas VM\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")